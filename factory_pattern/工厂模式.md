# 工厂模式

​	工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于**创建型模式**，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

​	说白了就是：不自己创对象，交给工厂，方便解耦。

## 工厂模式分类

在《设计模式之禅》这本书中分了两章节讲工厂模式：

- 工厂方法模式（包含简单工厂模式）
- 抽象工厂模式

网上的大部分资料都是将工厂模式分成**三**种：

- 简单/静态工厂模式
- 工厂方法模式
- 抽象工厂模式

## 为什么要用到工厂模式？

​	用什么工厂模式，我直接new不方便吗？下面举个例子给你看下方便不：

​	假设我们学过装饰器模式，什么？装饰器模式还没学过，那假设我们学过Java的IO流，没学过也没事，就反正你需要进行文件读取使用 BufferedReader：

```java
    BufferedReader bf = new BufferedReader(new FileReader(new File("aa.txt")));
```

​	然后你需要这个对象，你就得往里面丢进FileReader对象，然后FileReader对象还需要传入当前目录下的aa.txt。看着就很麻烦，什么？你说不麻烦，那万一你们单位来了个不长眼的实习生（说的是我）每个对象都喜欢new出来呢：

```java
 		File file = new File("aa.txt");
        FileReader fileReader = new FileReader(file);
        BufferedReader bufferedReader = new BufferedReader(fileReader);
```

​	要是一个部分需要用一次，那代码阅读起来简直裂开，就算你用这样的方式写完了，那以后换成 **LineNumberReader** 来读，你不更裂开，又得跑去重新弄。（虽然可以用idea的全局替换。。。）所以这就引出我们今天的主角，工厂模式了。

## 体验工厂模式

​	不介绍了，工厂说白了就是帮你干活的，你是掠夺者，你只需要调用它，它就会给你想要的，不多说了，在说要被续了，拿上面的例子举例：

* 先创建一个工厂，用来获取读取流：

```java
public class ReaderFactory {
    public static Reader getBufferedReader() throws FileNotFoundException {
        File file = new File("aa.txt");
        FileReader fileReader = new FileReader(file);
        BufferedReader reader = new BufferedReader(fileReader);
        return reader;
    }
}
```

* 使用即可，省去了很多步骤，并且如果需要修改我们只要在对应的工厂上改或者增加工厂方法就可以。

```java
    public static void main(String[] args) throws FileNotFoundException {
        Reader bufferedReader = ReaderFactory.getBufferedReader();
    }
```

## 使用工厂模式的好处

从上面的工厂模式体验我们就可以看到：

- 我们修改了具体的实现类，对客户端(调用方)而言是**完全不用修改的**。

- 如果我们使用`new`的方式来创建对象的话，那么我们就说：`new`出来的这个对象和当前客户端(调用方)**耦合**了！

- - 也就是，当前客户端(调用方)**依赖着**这个`new`出来的对象！